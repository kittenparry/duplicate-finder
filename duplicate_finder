#!/usr/bin/env python3

import os
import tkinter as tk
import platform
import time
import subprocess
import shutil

class COL:
	FAIL = '\033[91m'
	WARNING = '\033[93m'
	UNDERLINE = '\033[4m'
	BOLD = '\033[1m'
	ENDC = '\033[0m'

def get_files():
	LOOP_PARTITION_LETTERS = ['d', 'e', 'f', 'g', 'h', 'j']
	LOOP_PATH = [
		os.path.join('Archive', 'porn', 'vids'),
		os.path.join('Archive', 'porn', 'pics'),
		os.path.join('Downloads', 'porn'),
		os.path.join('arch', 'porn') # same as ARCH_DIR
	]
	dirs_prefix = []
	for letter in LOOP_PARTITION_LETTERS:
		dirs_prefix.append(os.path.join('/mnt', 'disk-%s' % letter))

	dirs_models = []
	for prefix in dirs_prefix:
		for suffix in LOOP_PATH:
			try:
				# append full path to model names
				dirs_models += [os.path.join(prefix, suffix, item) for item in os.listdir(os.path.join(prefix, suffix))]
			except FileNotFoundError:
				pass
			except Exception as e:
				print(e)

	# list of all files & directories
	obj_names = []
	obj_path = []
	for dire in dirs_models:
		try:
			obj_names += os.listdir(dire)
			obj_path += [os.path.join(dire, item) for item in os.listdir(dire)]
		except Exception as e:
			print(e)

	# names & paths to duplicates
	obj_list = []
	for n, name in enumerate(obj_names):
		if obj_names.count(name) > 1:
			obj = lambda: None
			obj.name = name
			obj.path = obj_path[n]
			obj_list.append(obj)

	# sort list by obj names
	obj_list = sorted(obj_list, key=lambda x: x.name)
	return obj_list

class Gui(tk.Frame):
	def __init__(self, master = None):
		tk.Frame.__init__(self, master)
		self.base = tk.Frame(master)
		self.sub = tk.Frame(master)
		self.bottom = tk.Frame(master)
		self.base.grid(row=0, column=0)
		self.sub.grid(row=1, column=0)
		self.bottom.grid(row=2, column=0)

		start = time.time()
		self.obj_list = get_files()
		end = time.time()
		self.passed = end - start
		self.output_items()

	def output_items(self):
		# TODO: likely add selection='multiple' to listbox
		# this might cause it to return a list, so change functions below accordingly
		self.listbox = tk.Listbox(self.base, height=25, width=100)
		self.btn_del = tk.Button(self.sub, text='Delete?', command=self.delete)
		self.btn_exp = tk.Button(self.sub, text='Explore', command=self.explore)
		self.time_passed = tk.Label(self.bottom, text='%.2f seconds to read files.' % self.passed)

		self.listbox.bind('<Double-1>', self.double_click_ev)

		self.build_list()

		self.listbox.grid(row=0, column=0)
		self.elements = [self.btn_del, self.btn_exp, self.time_passed]
		for el in self.elements:
			el.pack(side='left', pady=2, padx=1)

		self.xscroll = tk.Scrollbar(self.base, orient='horizontal', command=self.listbox.xview)
		self.xscroll.grid(row=1, column=0, sticky='ew')
		self.yscroll = tk.Scrollbar(self.base, orient='vertical', command=self.listbox.yview)
		self.yscroll.grid(row=0, column=1, sticky='ns')
		self.listbox.configure(yscrollcommand=self.yscroll.set, xscrollcommand=self.xscroll.set)
	
	def delete(self):
		path = self.listbox.get(self.listbox.curselection())
		print('%sdeleted%s: %s' % (COL.FAIL, COL.ENDC, path))
		shutil.rmtree(path)
		self.del_duplicates(path)

	def build_list(self):
		self.listbox.delete(0, 'end')
		# populate listbox with paths
		for n, obj in enumerate(self.obj_list):
			self.listbox.insert(n, obj.path)

	# delete duplicates from listbox
	def del_duplicates(self, path):
		# get first duplicate obj with the path
		for el in self.obj_list:
			if el.path == path:
				obj_one = el

		# get second one using first one's name
		for el in self.obj_list:
			if el.name == obj_one.name and el.path != obj_one.path:
				obj_two = el

		# remove both from the list
		if obj_one in self.obj_list:
			self.obj_list.remove(obj_one)
		if obj_two in self.obj_list:
			self.obj_list.remove(obj_two)

		self.build_list()

	# double click to list element also explores
	def double_click_ev(self, event):
		self.delete()

	def explore(self):
		path = self.listbox.get(self.listbox.curselection())
		if platform.system() == 'Linux':
			# FIXME:
			# subprocess.Popen(['xdg-open', path])
			# not using xdg-open for now
			# because ranger messes when I return to terminal
			# after shutting down the program
			subprocess.Popen(['pcmanfm', path])
		# initial path vars are not with Windows in mind
		# but let's just pretend for a moment
		elif platform.system() == 'Windows':
			os.startfile(path)



def get_geometry():
	if platform.system() == 'Linux':
		program_width = 817
		screen_width = 1920
		x_position = (screen_width - program_width) / 2
		geo_str = '%dx475+%d+30' % (program_width, x_position)
	return geo_str

def start_gui():
	root = tk.Tk(className='duplicate_finder')
	if platform.system() == 'Linux':
		root.tk.call('tk', 'scaling', 1.3)
	root.title('duplicate_finder')
	root.geometry(get_geometry())
	app = Gui(master=root)
	app.mainloop()


if __name__ == '__main__':
	start_gui()
